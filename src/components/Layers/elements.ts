import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { all, delay, put, select, take, takeLatest } from "redux-saga/effects";
import { TICK_EVENT, CoreState, newLore } from "../Core";

export enum Status {
  HIDDEN,
  DISCOVERABLE,
  ACTIVE,
  PASSIVE,
}

enum GeneratorMode {
  ALWAYS, // always drain source and grow target (default)
  ALWAYS_SRC, // always drain source the full value, only grow target proportional to drained source
  ALWAYS_DST, // always grow target the full value, only drain target proportional to grown target
  PROPORTIONAL, // only drain source and grow target proportional to available space
}

export type Element = "will" | "air" | "earth" | "fire" | "water";

export interface ElementState {
  status: Status;
  value: number;
  max: number;
  merge: string | false;
}

export interface ElementGenerator {
  name: string;
  src?: string;
  srcPerSecond?: number;
  dst?: string;
  dstPerSecond?: number;
  mode?: GeneratorMode;
}

export interface ElementsCollection<T> {
  will: T;
  air: T;
  earth: T;
  fire: T;
  water: T;
}

export interface ElementStatistics {
  manualGenerated: number;
  autoGenerated: number;
  manualConsumed: number;
  autoConsumed: number;
}
export interface AllElementStatistics {
  elements: ElementsCollection<ElementStatistics>;
}

export type ElementsState = {
  last: DOMHighResTimeStamp;
  elements: ElementsCollection<ElementState>;
  generators: ElementGenerator[];
  stats: AllElementStatistics;
};

function emptyStats() {
  return {
    manualGenerated: 0,
    autoGenerated: 0,
    manualConsumed: 0,
    autoConsumed: 0,
  };
}

function drainGenerator(name: string, rate = 0.1): ElementGenerator {
  return { name: name + '_drain', src: name, srcPerSecond: rate };
}

const initialState: ElementsState = {
  last: -1,
  elements: {
    will: { status: Status.HIDDEN, value: 0.0, max: 100.0, merge: false },
    air: { status: Status.HIDDEN, value: 0.0, max: 10.0, merge: false },
    earth: { status: Status.HIDDEN, value: 0.0, max: 10.0, merge: false },
    fire: { status: Status.HIDDEN, value: 0.0, max: 10.0, merge: false },
    water: { status: Status.HIDDEN, value: 0.0, max: 10.0, merge: false },
  },
  generators: [],
  stats: {
    elements: {
      will: emptyStats(),
      air: emptyStats(),
      earth: emptyStats(),
      fire: emptyStats(),
      water: emptyStats(),
    },
  },
};

export const GEN_COST = 10.0;

function applyGen(dt: number, { elements, stats }) {
  return (gen: ElementGenerator) => {
    const src = gen.src && elements[gen.src];
    const dst = gen.dst && elements[gen.dst];
    let srcDelta = 0;
    let dstDelta = 0;
    if (src && gen.srcPerSecond) {
      srcDelta = Math.min(src.value, dt * gen.srcPerSecond);
    }
    if (dst && gen.dstPerSecond) {
      dstDelta = Math.min(dst.max - dst.value, dt * gen.dstPerSecond);
    }

    if (gen.srcPerSecond && gen.dstPerSecond) {
      const srcRatio = srcDelta / gen.srcPerSecond;
      const dstRatio = dstDelta / gen.dstPerSecond;
      switch (gen.mode) {
        case GeneratorMode.ALWAYS_SRC:
          dstDelta *= srcRatio;
          break;
        case GeneratorMode.ALWAYS_DST:
          srcDelta *= dstRatio;
          break;
        case GeneratorMode.PROPORTIONAL:
          srcDelta = (srcDelta * dstRatio) / Math.max(srcRatio, dstRatio);
          dstDelta = (dstDelta * srcRatio) / Math.max(srcRatio, dstRatio);
      }
    }

    if (src) {
      src.value -= srcDelta;
      const srcStats: ElementStatistics = stats.elements[gen.src];
      srcStats.autoConsumed += srcDelta;
    }

    if (dst) {
      dst.value += dstDelta;
      const dstStats: ElementStatistics = stats.elements[gen.dst];
      dstStats.autoGenerated += dstDelta;
    }
  };
}

const slice = createSlice({
  name: "elements",
  initialState,
  reducers: {
    forceGen(state, action: PayloadAction<Element>) {
      if (state.elements.will.value < GEN_COST) return;

      const name = action.payload;
      const element = state.elements[name];

      state.elements.will.value -= GEN_COST;
      element.value = Math.min(element.max, element.value + 1.0);

      state.stats.elements.will.manualConsumed += GEN_COST;
      state.stats.elements[name].manualGenerated += 1.0; // TODO as much as was actually generated
    },
    merge(state, action: PayloadAction<{ from: Element; to: Element }>) {
      state = state;
    },
    reinit(state, action: PayloadAction<DOMHighResTimeStamp>) {
      state.last = action.payload;
    },
    onTick(state, action: PayloadAction<DOMHighResTimeStamp>) {
      const dt = action.payload - state.last;
      state.last = action.payload;
      state.generators.forEach(applyGen(dt, state));
    },
    story_revealWill(state) {
      console.log("Proccing story 1");
      state.elements.will.status = Status.DISCOVERABLE;
    },
    story_discoverWill(state) {
      console.log("Proccing story 2");
      state.elements.will.status = Status.PASSIVE;
      state.generators.push({
        name: "willGain",
        dst: "will",
        dstPerSecond: 10.0,
      });
    },
    story_focusWill(state) {
      console.log("Proccing story 3");
      state.elements.air.status = Status.DISCOVERABLE;
    },
    story_discoverElements(state) {
      console.log("Proccing story 4");
      for (const x of ["air", "earth", "fire", "water"]) {
        state.elements[x].status = Status.ACTIVE;
        state.generators.push(drainGenerator(x));
      }
    },
    story_mergeExperiments(state) {
      for (const x of ["will", "air", "earth", "fire", "water"]) {
        state.elements[x].merge = MERGE_EXPERIMENT;
      }
    },
    story_enableMerging(state) {
      for (const x of ["will", "air", "earth", "fire", "water"]) {
        state.elements[x].merge = MERGE_FULL;
      }
    },
  },
});

export const { forceGen } = slice.actions;

export default slice.reducer;

const { reinit, onTick } = slice.actions;

export const DISCOVER_WILL = "elements:will:discover";
export const FOCUS_WILL = "elements:will:focus";
export const MERGE_EXPERIMENT = "elements:merge:discover";

const MERGE_FULL = slice.actions.merge({ from: "will", to: "will" }).type;

function* waitForState(selector, test) {
  let state = yield select(selector);
  while (!test(state)) {
    yield take();
    state = yield select(selector);
  }
}

function* elementsStory() {
  yield put(newLore("You are floating, formless in the void."));
  yield delay(5000);
  yield put(newLore("Formless, but you exist. How do you exist?"));
  yield delay(5000);
  yield put(
    newLore(
      "You have no form, but you have thought. " +
        "Can you gather your thoughts somehow?",
    ),
  );
  yield put(slice.actions.story_revealWill());
  yield take(DISCOVER_WILL);
  yield put(slice.actions.story_discoverWill());
  yield delay(5000);
  yield put(
    newLore(
      "Your thoughts seem to be having an effect on the void. " +
        "What will happen if you focus your will?",
    ),
  );
  yield put(slice.actions.story_focusWill());
  yield take(FOCUS_WILL);
  yield put(
    newLore(
      "Your will can bring form to the void. " +
        "You notice four distinct forms you can create, and call them *Elements*",
    ),
  );
  yield put(slice.actions.story_discoverElements());
  yield waitForState(
    (state) => state.elements,
    (state: ElementsState) => {
      return (
        10 <=
        state.stats.elements.air.manualGenerated +
          state.stats.elements.earth.manualGenerated +
          state.stats.elements.fire.manualGenerated +
          state.stats.elements.water.manualGenerated
      );
    },
  );
  yield put(
    newLore(
      "The excitement of creating elements from thought quickly fades, and so do the elements. " +
        "Is there anything you can *do* with the elements you create?",
    ),
  );
  yield merge_experiments();
}

function* merge_experiments() {
  yield put(slice.actions.story_mergeExperiments());
  while (true) {
    const {
      payload: { from, to },
    } = yield take(MERGE_EXPERIMENT);

    if ((from === "will") !== (to === "will")) {
      yield put(newLore("Nah, yeah!"));
      yield put(slice.actions.story_enableMerging());
      return;
    }

    yield put(newLore("Yeah, nah"));
  }
}

export function* elementGeneration() {
  const firstTick = yield take(TICK_EVENT);
  yield put(reinit(firstTick.payload));

  yield takeLatest(TICK_EVENT, function* () {
    const now = yield select((state: CoreState) => state.time.now);
    yield put(onTick(now));
  });
}

export function* elementsSaga() {
  yield all([elementsStory(), elementGeneration()]);
}
